<!DOCTYPE html>
<html>
<head>
    <title>Magic Printer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <style>
        body { background-color: #000; color: #fff; font-family: -apple-system, sans-serif; text-align: center; padding: 20px; display: flex; flex-direction: column; height: 90vh; justify-content: center; }
        
        .btn {
            display: block; width: 100%; padding: 25px; margin: 15px 0;
            font-size: 20px; font-weight: bold; border-radius: 12px; border: none;
            cursor: pointer; text-transform: uppercase;
        }
        
        .btn-blue { background: #007AFF; color: white; }
        .btn-green { background: #34C759; color: black; box-shadow: 0 0 20px #34C759; }
        .btn-gray { background: #333; color: #777; }

        #status { margin-top: 15px; color: #888; font-size: 14px; }
        #preview { width: 200px; border: 2px solid #333; margin: 20px auto; display: none; filter: grayscale(100%); border-radius: 10px; }
    </style>
</head>
<body>

    <h2 id="mainStatus">STEP 1: CONNECT</h2>

    <button id="connectBtn" class="btn btn-blue" onclick="connectBluetooth()">ðŸ”Œ CONNECT PRINTER</button>
    
    <button id="pasteBtn" class="btn btn-gray" onclick="pasteAndPrint()" style="display:none;" disabled>
        ðŸ“‹ PASTE & PRINT
    </button>

    <img id="preview" alt="Preview">
    <div id="status">Ready...</div>
    
    <canvas id="processCanvas" style="display:none;"></canvas>

    <script>
        // --- BLUETOOTH CONFIG ---
        const PRINTER_WIDTH = 384; 
        const CHUNK_SIZE = 100;
        let device, characteristic;

        const serviceUuid = '000018f0-0000-1000-8000-00805f9b34fb';
        const charUuid = '00002af1-0000-1000-8000-00805f9b34fb';

        // --- 1. CONNECT (BROADER SEARCH) ---
        async function connectBluetooth() {
            try {
                updateStatus("Scanning...");
                // REMOVED strict name filter. Now searches for ANY PeriPage.
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'PeriPage' }],
                    optionalServices: [serviceUuid]
                });

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(serviceUuid);
                characteristic = await service.getCharacteristic(charUuid);
                
                // Switch UI
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('pasteBtn').style.display = 'block';
                document.getElementById('pasteBtn').className = "btn btn-green";
                document.getElementById('pasteBtn').disabled = false;
                document.getElementById('mainStatus').innerText = "STEP 2: PRINT";
                
                updateStatus("Connected! Copy photo and click Paste.");

            } catch (error) {
                updateStatus("Connect Failed: " + error);
            }
        }

        // --- 2. PASTE FROM CLIPBOARD ---
        async function pasteAndPrint() {
            try {
                updateStatus("Reading Clipboard...");
                
                // Read Clipboard Items
                const clipboardItems = await navigator.clipboard.read();
                for (const item of clipboardItems) {
                    // Find an image type
                    const type = item.types.find(t => t.startsWith('image/'));
                    if (type) {
                        const blob = await item.getType(type);
                        const img = new Image();
                        img.onload = function() {
                            // Show Preview
                            document.getElementById('preview').src = img.src;
                            document.getElementById('preview').style.display = 'block';
                            processAndPrint(img);
                        };
                        img.src = URL.createObjectURL(blob);
                        return;
                    }
                }
                alert("No image found in clipboard!");
            } catch (err) {
                // Fallback for browsers blocking clipboard read
                alert("Clipboard access denied. Please allow paste.");
                updateStatus("Error: " + err);
            }
        }

        // --- 3. PRINTING LOGIC ---
        function processAndPrint(img) {
            updateStatus("Processing...");
            const canvas = document.getElementById('processCanvas');
            const ctx = canvas.getContext('2d');
            
            const scale = PRINTER_WIDTH / img.width;
            const height = Math.floor(img.height * scale);
            canvas.width = PRINTER_WIDTH;
            canvas.height = height;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, PRINTER_WIDTH, height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Dither
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                data[i] = data[i+1] = data[i+2] = avg < 128 ? 0 : 255;
            }
            
            printData(data, PRINTER_WIDTH, height);
        }

        async function printData(pixels, width, height) {
            updateStatus("Printing...");
            const rowBytes = width / 8;
            const bitBuffer = new Uint8Array(rowBytes * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (pixels[i] === 0) { 
                        const bytePos = (y * rowBytes) + Math.floor(x / 8);
                        bitBuffer[bytePos] |= (1 << (7 - (x % 8)));
                    }
                }
            }

            const chunks = Math.ceil(height / CHUNK_SIZE);
            for (let c = 0; c < chunks; c++) {
                const start = c * CHUNK_SIZE;
                const end = Math.min((c+1)*CHUNK_SIZE, height);
                const h = end - start;
                
                const header = new Uint8Array([0x1D, 0x76, 0x30, 0x00, rowBytes, 0x00, h & 0xFF, (h >> 8) & 0xFF]);
                const body = bitBuffer.slice(start * rowBytes, end * rowBytes);
                const packet = new Uint8Array(header.length + body.length);
                packet.set(header);
                packet.set(body, header.length);
                
                await characteristic.writeValue(packet);
                await new Promise(r => setTimeout(r, 20));
            }
            await characteristic.writeValue(new Uint8Array([0x1B, 0x4A, 150])); 
            updateStatus("DONE!");
        }

        function updateStatus(msg) {
            document.getElementById('status').innerText = msg;
        }
    </script>
</body>
</html>
